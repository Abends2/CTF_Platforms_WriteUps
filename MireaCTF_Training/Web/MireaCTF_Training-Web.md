# MireaCTF – Tasks from Training Platform

---

## Task 1: hranilka

Переходим на сайт и наблюдаем то, что мы можем получить какой-то текстовый файлик:

![ScreenShot](screenshots/1.png)

Пробуем его получить, но видим сообщение о том, что файл просто найден, но самого файла мы не получаем:

![ScreenShot](screenshots/2.png)

Откроем Burp Suite. Перейдем в раздел Proxy, далее нажимаем на Intercept is off, чтобы перейти в активный режим (Intercept is on). Далее Open Browser, в открывшемся браузере вставляем ссылку и переходим на сайт. Регулирование переходов осуществляется при помощи кнопки Forward (или Drop). Теперь нажмем на кнопку внутри сайта для получения файла. В итоге запрос на получение перехвачен:

![ScreenShot](screenshots/3.png)

Вместо того, чтобы получать файл, загрузим его при помощи метода PUT:

![ScreenShot](screenshots/4.png)

После преобразования запроса нажимаем на Forward и смотрим на результат в браузере:

![ScreenShot](screenshots/5.png)

Файл успешно добавлен. Тогда попробуем его получить обратно:

![ScreenShot](screenshots/6.png)

Нажимаем на Forward и смотрим на результат:

![ScreenShot](screenshots/7.png)

Флаг: MireaCTF{intercept_change_win}

---

## Task 2: bykvi

Открываем ссылку по аналогии с прошлым таском, но теперь для наглядности появившийся запрос переместим в Repeater. Для этого в появившемся запросе в окне Proxy нажимаем ПКМ и затем Send to Repeater:

![ScreenShot](screenshots/8.png)

Перейдем во вкладку Repeater и нажмем на Send, посмотрим на ответ:

![ScreenShot](screenshots/9.png)

Отправим полученный ответ в Decoder:

![ScreenShot](screenshots/10.png)

Decoder может работать в нескольких режимах – можно явно указать кодировку или же применить smart decode. Посмотрим, что у нас происходит в данном таске. Знак «=» указывает скорее всего на кодировку base64. Выбираем Decode as… и Base64:

![ScreenShot](screenshots/11.png)

Получаем следующий результат: 

![ScreenShot](screenshots/12.png)

Далее не совсем понятно, что применить, поэтому попробуем обратиться к Smart decode:

![ScreenShot](screenshots/13.png)

Флаг: Some_interesting_data

---

## Task 3: greetings

При открытии страницы есть только «Admin» и «false». Открываем ссылку в Chromium (браузер в Burp Suite). Сначала видим что идет обычный запрос на показ содержимого сайта:

![ScreenShot](screenshots/14.png)

Далее нажимаем Forward и видим, что есть второй запрос через WebSocket. Ответом получаем 101 (код ответа, указывающий на то, что рукопожатие продолжается), потому жмем еще раз Forward:

![ScreenShot](screenshots/15.png)

Получаем данные, которые впоследствии будут переданы серверу:

![ScreenShot](screenshots/16.png)

Меняем в поле «admin» значение на true:

![ScreenShot](screenshots/17.png)

Нажимаем Forward и получаем в ответе флаг:

![ScreenShot](screenshots/18.png)

Флаг: MireaCTF{w3b-r0z37k4}

---

## Task 4: logarithm

Открываем сайт:

![ScreenShot](screenshots/19.png)

Попробуем получить значение логарифма от какого-нибудь числа:

![ScreenShot](screenshots/20.png)

В общем-то нам надо найти такое значение, которое в ответе на запрос выдаст флаг. Перебирать 100 разных вариантов руками нецелесообразно, к счастью, Burp Suite может перебирать это сам, по крайней мере числа перебирает из коробки. Смотрим, как настроить такую атаку.

Для начала перебросим запрос в Intruder (как перекидывать запрос в другие разделы я описывал ранее):

![ScreenShot](screenshots/21.png)

Теперь поставим специальные символы в запрос. Между этими специальными символами Burp будет сам вставлять значения, которые мы выберем далее:

![ScreenShot](screenshots/22.png)

Далее внутри вкладки Intruder перейдем в раздел payloads и зададим значения:

![ScreenShot](screenshots/23.png)

Далее нажимаем на Start Attack и следим за списком запросов-ответов. Ориентироваться можно на длину. Если везде она примерно от 215 до 219, то в запросе c /71 длина ответа составляет 202. Тут же можно и проверить response:

![ScreenShot](screenshots/24.png)

Флаг: MireaCTF{4u70m4t3_3v3ry7h1ng}

---

## Task 5: Domain Check

Откроем сайт:

![ScreenShot](screenshots/25.png)

Видим только 1 окно ввода. Попробуем ввести что-нибудь:

![ScreenShot](screenshots/26.png)

А если таааак:

![ScreenShot](screenshots/27.png)

Так, разбираемся! если мы вводим условный домен и через символ «;» отделим команду, то в поле ввода этого символа не будет. Выясняем, почему так происходит. Заглянем в инспектор: 

![ScreenShot](screenshots/28.png)

А вот и причина, по которой символ пропадает – на сайте присутствует фильтрация некоторых вводимы символов. Тогда перехватим наш запрос и сделаем магию (принцип будет позже). Вводим в поле ввода «vk.com», предварительно закинув сайт в Burp. Видим перехваченное вводимое значение:

![ScreenShot](screenshots/29.png)

Если мы отправим его дальше, то в итоге результат естественно не поменяется, поэтому модернизируем запрос так, как нам необходимо. В частности, попробуем ввести запрос на просмотр директорий:

![ScreenShot](screenshots/30.png)

Нажимаем Forward и смотрим ответ:

![ScreenShot](screenshots/31.png)

Вот таким вот образом выполняются две команды сразу, хоть это и не было предусмотрено изначально. Самое интересное – почему сейчас сервер обработал модифицированную часть запроса, а не отбросил ее из-за символа «;»? 

Все довольно просто. Изначально мы вводим обычный домен, затем js-скрипт проверяет и фильтрует специальные символы, указанные в массиве (см. скрины выше), не найдя ничего подозрительного происходит формирование и отправка запроса, который в свою очередь уже перехватываем мы, но теперь, когда мы модифицируем запрос и отправляем его далее, js-скрипт не срабатывает, т.к. он остался «позади» на сайте, а мы уже после перехвата, пересылаем запрос напрямую к серверу, поэтому и происходит обработка двух команд. Ну что же, читаем флаг:

![ScreenShot](screenshots/32.png)

![ScreenShot](screenshots/33.png)

Флаг: MireaCTF{7h3_fu7ur3}

---
